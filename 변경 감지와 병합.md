# 변경 감지와 병합

#### 준영속 엔티티란? 영속성 컨텍스트가 더 이상 관리하지 않는 엔티티

#### 준영속 상태인 엔티티 수정을 위한 2가지 방법
  - 변경 감지
  - 병합(merge)

##### 1. 변경 감지
```java
@Transactional
public void update(Entity entity) {                           // entity: 파라미터로 넘어온 준영속 상태의 엔티티
  Entity findEntity = em.find(Entity.class, entity.getId());  // 준영속 상태의 엔티티 id 값으로 같은 엔티티를 다시 조회한다.
  findEntity.setXXX(entity.getXXX);
  findEntity.setYYY(entity.getYYY);
  findEntity.setZZZ(entity.getZZZ);                           // 데이터를 수정한다.
}
```

- 영속성 컨텍스트에서 엔티티를 다시 조회한 후 데이터를 수정한다.
- 이는 Service 레벨에서, transaction 안에서 엔티티를 다시 조회하며 값을 수정한다. 변경 감지는 원하는 필드만 선택적으로 값 변경이 가능하다.
  -> transaction commit 시점에 변경 감지(dirty checking)가 동작하여 DB에 UPDATE 쿼리를 실행.

#### 2. 병합(merge)
- 준영속 상태의 엔티티를 영속 상태로 변경하여 사용하는 방법이다.

```java
@Transactional
public void update(Entity entity) {                           // entity: 파라미터로 넘어온 준영속 상태의 엔티티
  Entity mergeEntity = em.merge(entity);
}
```

- 동작 방식
  - merge()를 실행한다.
  - 파라미터로 넘어온 준영속 엔티티의 식별값으로 엔티티를 조회한다. 만약 1차 캐시에 엔티티가 있으면 거기서 가져오고, 없으면 DB에서 값을 가져오며 1차 캐시에 저장한다.
  - 식별자 값으로 찾아온 영속 엔티티에 준영속 엔티티의 값을 밀어넣는다. 이 때 merge()는 특정 값만 변경하는 것이 아닌 모든 필드의 값을 통째로 밀어넣는다. 병합 시 값이 없으면 null로 업데이트하여 문제가 발생할 수 있다.
  - 준영속 엔티티 값으로 새롭게 셋팅된 영속 상태의 엔티티를 반환한다. 변경 감지와 마찬가지로, transaction commit 시점에 결국 변경 감지가 동작하여 DB에 UPDATE 쿼리를 실행.






